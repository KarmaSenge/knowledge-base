<!DOCTYPE html>
<html lang="cs_CZ">
<head>
 <meta charset="utf-8"/>
 <title>Automaticke Uvazovani</title><link rel="stylesheet" href="../components/bootstrap/css/bootstrap.css"/><link rel="stylesheet" href="../components/kmdoc/assets/css/style.css"/><link rel="stylesheet" href="../components/kmdoc/assets/jquery-bootstrap/jquery-ui-1.9.2.custom.css"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script><script src="../components/jquery-ui/ui/jquery-ui.js"></script><script src="../components/underscore/underscore.js"></script><script src="../components/kmdoc/assets/js/main.js"></script><link rel="stylesheet" href="../components/kmdoc/node_modules/markmap/view.mindmap.css"/><script src="../components/kmdoc/node_modules/markmap/node_modules/d3/d3.min.js"></script><script src="../components/kmdoc/node_modules/markmap/view.mindmap.js"></script><script src="../components/kmdoc/assets/js/mindmap.js"></script><script>_.extend(KMDoc.modules.mindmap.options, {"autoOpen":false,"out":"index-mindmap.json","mindmapUrl":"index-mindmap.json"});</script><link rel="stylesheet" href="../components/kmdoc/assets/css/toc.css"/><script src="../components/kmdoc/assets/libs/jquery.toc.js"></script><script>$(function() {$("body").append("<div id=\"toc\"></div>").css("margin-right", 160); $("#toc").css("right", 0).toc({offset:-40});});</script><script src="../components/kmdoc/assets/libs/jquery.masonry.min.js"></script><script src="../components/kmdoc/assets/js/columns.js"></script><script src="../components/kmdoc/assets/js/tooltip.js"></script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="../components/kmdoc/assets/js/recall.js"></script><script src="../components/kmdoc/assets/js/autolink.js"></script><script src="../components/kmdoc/assets/libs/czech-stemmer/stringbuffer.js"></script><script src="../components/kmdoc/assets/libs/czech-stemmer/agressive.js"></script><script src="../components/kmdoc/assets/libs/czech-stemmer/light.js"></script><script>KMDoc.modules.autolink.options.stem = function(str) {return czech_stem(str.toLowerCase());}; </script><script src="../components/kmdoc/assets/libs/latinize/latinize.js"></script><script src="../components/kmdoc/assets/js/search.js"></script><script>KMDoc.modules.tooltip.options.actions[1] = _.template('<a href="http://cs.wikipedia.org/w/index.php?search=<%=name%>" title="Wikipedia" target="_blank"><img class="favicon" src="http://cs.wikipedia.org/favicon.ico"></a>'); KMDoc.modules.columns.options.columns = 1;</script><script>KMDoc.definitionsUrl = "index-definitions.json";</script>
</head>
<body>

<div class="navbar navbar-inverse navbar-fixed-top"><div class="navbar-inner"><a class="brand" href="#">Automaticke Uvazovani</a><ul class="nav"><li class="divider-vertical"></li><li><a href="../">KMDoc Knowledge Base</a></li></ul><div class="control-toolbar"></div></div></div>

<div class="section"><h1 id="automatick-uva-ov-n-">Automatické uvažování</h1>
<p>Zde jsou poznámky z předmětu <a href="https://cw.fel.cvut.cz/wiki/courses/a4m33au/start">Automatické uvažování (A4M33AU)</a> vyučovaném na <a href="https://www.fel.cvut.cz/cz">ČVUT FEL</a>.</p>
<p>Dále doporučuji tuto stránku o <a href="http://www.phil.muni.cz/fil/logika/vl.php">výrokové logice</a>.</p>
</div><div class="section"><h2 id="-vod">Úvod</h2>
<div class="definition" id="pozorovani"><dt>Pozorování</dt><dd>pozorováním lze získat omezené znalosti týkající se objektů v našem dosahu.</dd></div>


<div class="definition" id="uvazovani"><dt>Uvažování</dt><dd>Konstruování (neintuitivních) závěrů z daných předpokladů. Cílem uvažování je odvodit znalost, kterou nemůžeme (nebo nechceme) získat pozorováním. Uvažování je smysluplné (korektní), pokud jím získané závěry jsou pravdivé.</dd></div>


<div class="definition" id="logika"><dt>Logika</dt><dd>Matematický obor zkoumající exaktní postupy uvažování.</dd></div>


<div class="definition" id="syntaxe"><dt>Syntaxe</dt><dd>Syntaxe logiky je ta část logiky, která se zabývá formální popisem logického jazyka, aniž by mu přiřazovala význam či zkoumala pravdivost.</dd></div>


<div class="definition" id="semantika"><dt>Sémantika</dt><dd>je ta část logiky, která se zabývá přiřazováním významu symbolům a dalším konstrukcím jazyka logiky.</dd></div>


<div class="definition" id="korektnost"><dt>Korektnost</dt><dd>Uvažování (v logice i jinde) přináší prospěch jen pokud jeho výsledky jsou pravdivá tvrzení. Takovému uvažování (takovým deduktivním pravidlům) říkáme korektní.</dd></div>


<div class="definition" id="nekonzistentni-systemy"><dt>nekonzistentní systémy</dt><dd>systémy, v nichž lze dokázat nepravdivá tvrzení.</dd></div>


<div class="definition" id="neuplne-systemy"><dt>neúplné systémy</dt><dd>systémy ve kterých nelze dokázat to, co potřebujeme.</dd></div>


<div class="definition" id="russeluv-paradox"><dt>Russelův paradox</dt><dd>Pokud použijeme neformální definici množiny: Všechny objekty s danou vlastnosti tvoří množinu.</dd></div>


<div class="definition" id="godelova-veta"><dt>Gödelova věta</dt><dd>ne všechna pravdivá tvrzení lze formálně dokázat.</dd></div>


<div class="definition" id="algoritmus-britskeho-muzea"><dt>Algoritmus Britského muzea</dt><dd>každé dokazatelné tvrzení lze dokázat strojově. Pomocí odvozovacích pravidel postupně generujeme důkazy všech pravdivých tvrzení. Jistě takto jednou najdeme i důkaz tvrzení, které chceme dokázat. Obecně ale nelze každé dokazatelné tvrzení dokázat efektivně.</dd></div>



<div class="definition" id="automaticke-uvazovani"><dt>Automatické uvažování</dt><dd>zkratka ATP (automated theorem proving). Rozdělení: Hledání modelů (model finding), Kontrola modelů.</dd></div>


<div class="definition" id="automaticke-dokazovani"><dt>Automatické dokazování</dt><dd>Cílem je počítačem z dané množiny předpokladů logicky odvodit platnost daného závěru. Výsledkem je: důkaz závěru z předpokladů (nebo jen konstatování, že je tvrzení dokazatelné). Nebo konstatování, že tvrzení je nedokazatelné (pouze někdy!). Nebo není schopen systém rozhodnout v rámci daných omezení (čas, paměť, ...).</dd></div>


<div class="definition" id="kontrola-modelu"><dt>Kontrola modelů</dt><dd>Formálně: zkoumáme, zda platí tvrzení v dané interpretaci – v rámci daného přiřazení významu logického jazyka.</dd></div>


<div class="definition" id="hledani-modelu"><dt>Hledání modelů</dt><dd>Formálně: hledáme model množiny formulí.</dd></div>


<div class="definition" id="interaktivni-systemy"><dt>Interaktivní systémy</dt><dd>pracují v menších krocích. Operátor systému „napovídá“, jaké taktiky má zkoušet a směruje ho tak k cíli.</dd></div>


<div class="definition" id="automaticke-systemy"><dt>Automatické systémy</dt><dd>se snaží zcela samostatně vyřešit úlohu.</dd></div>

<p>Dostupné nástroje automatického uvažování</p>
<ul>
<li>Pro predikátovou logiku prvního řádu: E, Otter, Prover9, SPASS, Vampire,
Waldmeister (rovnicový), aj.</li>
<li>Pro logiky vyšších řádů: ACL2, Coq, HOL, Isabelle, Nqthm, Agda, aj.</li>
<li>Knihovna TPTP (www.tptp.org) s problémy zapsanými v predikátové logice prvního řádu. Má interface na webu.</li>
</ul>
</div><div class="section"><h2 id="rezolu-n-kalkulus-pro-v-rokovou-logiku">Rezoluční kalkulus pro výrokovou logiku</h2>
<div class="definition" id="interpretace"><dt>Interpretace</dt><dd>Interpretace M je zobrazení, které přiřazuje každé výrokové proměnné význam – nepravda nebo pravda, nebo jako hodnoty 0 nebo 1.</dd></div>


<div class="definition" id="model"><dt>Model</dt><dd>Jestliže je formule φ pravdivá v dané interpretaci M, říkáme, že M je model φ, značíme: M |= φ. Říkáme též, že M splňuje φ.</dd></div>


<div class="definition" id="semanticky-dusledek"><dt>Sémantický důsledek</dt><dd>Jestliže ψ platí ve všech interpretacích, ve kterých platí φ, říkáme, že ψ je sémantický důsledek φ. Značení: φ ⊨ ψ</dd></div>

<p>Poznámky</p>
<ul>
<li>Pozorování: Relace &quot;⊨&quot; na formulích je reflexivní a tranzitivní.</li>
<li>Je-li současně φ ⊨ ψ a ψ ⊨ φ, říkáme, že tyto formule jsou sémanticky ekvivalentní nebo také ekvi-splnitelné, někdy značeno φ ⧦ φ.</li>
<li>Někdy se rozlišuje značením, že M je model formule ψ a že ψ je sémantickým důsledkem φ: M⊧ψ, φ⊨ψ.</li>
</ul>
<div class="definition" id="tautologie"><dt>Tautologie</dt><dd>Jestliže formule φ platí ve všech interpretacích, nazýváme jí tautologie. Značení: ⊨ φ</dd></div>

<p>Tautologie - vlastnosti</p>
<ul>
<li>Každá interpretace je modelem (libovolné) tautologie.</li>
<li>Každá tautologie je sémantickým důsledkem libovolné formule, například b ⊨ (a | ¬a)</li>
<li>Důsledek: všechny tautologie jsou sématicky ekvivalentní.</li>
</ul>
<div class="definition" id="kontradikce"><dt>Kontradikce (Spor)</dt><dd>Jestliže formule ψ není splněná v žádné interpretaci, nazveme jí kontradikce, nebo sporná formule.</dd></div>



<div class="definition" id="sporna-mnozina"><dt>Sporná množina</dt><dd>Množinu formulí, která není splněná v žádné interpretaci, nazveme spornou množinou.</dd></div>

<p>Kontradikce (spor) – vlastnosti</p>
<ul>
<li>Sporná formule (množina) nemá žádný model.</li>
<li>Libovolná formule je sémantickým důsledkem sporné formule (množiny), například: (a &amp; ¬a) ⊨ b</li>
<li>Důsledek: Všechny kontradikce jsou sémanticky ekvivalentní.</li>
<li>Formule je sporná právě když její negace je tautologie a naopak.</li>
</ul>
<div class="definition" id="logicky-kalkulus"><dt>Logický kalkulus (Logický deduktivní kalkulus)</dt><dd>Mechanismus, které umožňují zjistit (odvodit) pravdivost formule syntaktickými prostředky, tedy pouze prací se symboly, kterými jsou formule zapsány. Každý logický kalkulus se skládá z:<br><em>jazyka</em>, ve kterém se zapisují jeho formule;<br><em>axiomů</em>, což jsou formule, jejichž platnost v daném kalulu implicitně předpokládáme;<br><em>odvozovacích pravidel</em>, která říkají, jaké formule můžeme odvodit z axiomů, nebo z jiných již odvozených formulí.</dd></div>


<div class="definition" id="dukaz"><dt>Důkaz</dt><dd>Důkaz v daném logickém kalkulu je taková konečná posloupnost formulí, kde každá formule je buďto:<br><em>jeden z axiomů</em>, nebo<br><em>odvozená</em> pomocí některého logického pravidla kalkulu z předcházejících formulí v posloupnosti.</dd></div>


<div class="definition" id="dokazatelnost"><dt>Dokazatelnost</dt><dd>Řekneme, že formule ψ je dokazatelná z množiny formulí A, pokud existuje důkaz ψ z A. Značení: A ⊦ ψ.</dd></div>


<div class="definition" id="hilbertuv-implikativni-kalkulus-pro-vyrokovou-logiku"><dt>Hilbertův implikativní kalkulus pro výrokovou logiku</dt><dd>má odvozovací pravidlo modus ponens.</dd></div>


<div class="definition" id="korektnost-logickeho-kalkulu"><dt>Korektnost logického kalkulu</dt><dd>Logický kalkulus je korektní, jestliže platí: všechny axiomy jsou tautologie, a pokud z formulí φ1,...,φn odvodíme ψ, musí platit φ,...,φ⊨ ψ. Čili, vše, co je dokazatelné, je pravda.</dd></div>


<div class="definition" id="uplnost-logickeho-kalkulu"><dt>Úplnost logického kalkulu</dt><dd>Vše, co je pravda, je dokazatelné.</dd></div>


<div class="definition" id="rezolucni-kalkulus"><dt>Rezoluční kalkulus</dt><dd>Rezoluční kalkulus umožňuje dokázat, že je daná množina tzv. klauzulí sporná, tedy zda v žádné interpretaci nelze splnit všechny dané formule. Úlohu je tedy nejprve nutné převést na hledání důkazu sporu z nějaké množiny klauzulí.</dd></div>


<p>Jazyk rezolučního kalkulu pro výrokovou logiku</p>
<div class="definition" id="literal"><dt>Literál</dt><dd>je výroková proměnná nebo její negace.</dd></div>


<div class="definition" id="klauzule"><dt>Klauzule</dt><dd>je disjunkce libovolného počtu literálů.</dd></div>




<div class="definition" id="prazdna-klauzule"><dt>Prázdná klauzule</dt><dd>je klauzule, která neobsahuje žádný literál. Tato je ekvivalentní (každé) kontradikci. Značení , někdy též ⊥ nebo {}.</dd></div>

<p>Axiomy, odvozovací pravidlo výrokové rezoluce</p>
<ul>
<li>Výroková rezoluce nemá žádné axiomy (stejně tak predikátová).</li>
<li>Výroková rezoluce má pouze jedno odvozovací pravidlo:</li>
</ul>
<pre><code>    D|a         ¬a | G
    ----------------------
        D|G
</code></pre><ul>
<li>kde D a G jsou disjunkce libovolného počtu literálů (klauzule).</li>
<li>Výsledná klauzule „D | G“ se nazývá <em>rezolventa</em>.</li>
</ul>
<div class="definition" id="veta-o-uplnosti-rezolucniho-kalkulu"><dt>Věta (o úplnosti rezolučního kalkulu) (refutationally complete)</dt><dd>Buď A sporná množina klauzulí. Pak lze rezolučním kalkulem odvodit prázdnou klauzuli (spor).</dd></div>

<p>Použití rezolučního kalkulu</p>
<ol>
<li>Převedeme úlohu na hledání důkazu
spornosti množiny formulí.</li>
<li>Formule převedeme do CNF (na klauzule).</li>
<li>Aplikujeme rezoluční kalkulus.</li>
</ol>
<div class="definition" id="metoda-dukazu-sporem"><dt>Metoda důkazu sporem</dt><dd>Věta: A ⊨ φ právě když A∪{¬φ} ⊨  (jinak řečeno, A∪{¬φ} je sporná množina formulí).</dd></div>

<p>Převedení formulí na CNF</p>
<ul>
<li>Všechny logické spojky přepíšeme pomocí konjunkce, disjunkce a negace.</li>
<li>Pomocí DeMorganových pravidel přesuneme všechny negace co nejhlouběji, až k výrokovým proměnným.</li>
<li>Průběžně eliminujeme dvojité negace.</li>
<li>Distributivním pravidlem roznásobíme konjunkce a disjunkce tak, aby všechny disjunkce byly uvnitř konjunkcí.</li>
</ul>
<p>Strategie aplikace rezolučního pravidla</p>
<ul>
<li>Při použití rezoluce (i jiných důkazových
mechanismů) musíme (my, nebo automatický dokazovač) volit, na které dvě klauzule použít rezoluční pravidlo.</li>
<li>Snahou je vybírat takové klauzule, které nejspíš povedou ke krátkému důkazu.</li>
</ul>
<div class="definition" id="strategie-aplikace-rezolucniho-pravidla"><dt>Strategie aplikace rezolučního pravidla</dt><dd><br></dd></div>


<div class="definition" id="optimalizace-konverze-na-cnf"><dt>Optimalizace konverze na CNF</dt><dd><br></dd></div>


<div class="definition" id="subsumpce"><dt>Subsumpce</dt><dd>Jestliže φ⊆ψ ve smyslu množin literálů, říkáme, že formule φ subsumuje formuli ψ. Značme φ ⊑ ψ.</dd></div>


<div class="definition" id="subsumpce-v-rezoluci"><dt>Subsumpce v rezoluci</dt><dd>Pokud existuje rezoluční důkaz sporu z B a platí-li A ⊑ B, pak: <br>- existuje rezoluční důkaz sporu z A;<br>- ten lze mechanicky sestrojit, a<br>- není delší než důkaz z B.</dd></div>


<div class="definition" id="dopredna-subsumpce"><dt>Dopředná subsumpce (forward)</dt><dd>Vždy ponecháváme subsumující klauzuli (tu s méně literály, vlevo od ⊑ )</dd></div>


<div class="definition" id="zpetna-subsumpce"><dt>Zpětná subsumpce (backward)</dt><dd>zahazujeme subsumovanou klauzuli (tu s více literály, vpravo od ⊑ ).</dd></div>


<div class="definition" id="usporadana-rezoluce"><dt>Uspořádaná rezoluce</dt><dd>Myšlenka: Abychom dospěli k prázdné klauzuli, musíme z nějaké klauzule odstranit postupně všechny literály.<br>Nezávisí na pořadí, v jakém literály odstraňujeme.<br>Tím, že nějaké pořadí zvolíme, omezíme množství odvozených klauzulí.</dd></div>


<div class="definition" id="kvaziusporadani"><dt>Kvaziuspořádání</dt><dd>≼ je reflexivní tranzitivní relace.</dd></div>


<div class="definition" id="linearni-usporadani"><dt>Lineární uspořádání</dt><dd>≼ je totální kvaziuspořádání, tedy takové, kde platí, že pro libovolné A a B platí A ≼ B nebo B ≼ A (obecně může platit i obojí najednou).</dd></div>


<div class="definition" id="uplnost-usporadane-rezoluce"><dt>Úplnost uspořádané rezoluce</dt><dd>Věta: Z každé sporné množiny klauzulí S lze uspořádanou rezolucí odvodit spor.</dd></div>

</div><div class="section"><h2 id="rezolu-n-kalkulus-pro-logiku-prvn-ho-du">Rezoluční kalkulus pro logiku prvního řádu</h2>
</div><div class="section"><h2 id="tableaux-metody">Tableaux metody</h2>
<div class="definition" id="tableau-metoda"><dt>Tableau metoda</dt><dd>se užívaná pro automatické dokazování vět v predikátové logice, ale i
v dalších (modálních, temporálních, aj.) logikách.
Sémantické tableau je strom, kde každý uzel je logická
formule.
Sémantické tableau vzniká iterativně z předchozích
tableaux postupnou aplikací určitých pravidel.
Dokazování pomocí tableau metody postupně rozděluje
vstupní formuli na menší formule, dokud na všech větvích
stromu nenajde komplementární páry formulí nebo pokud
už nemůže aplikovat žádné z pravidel.
Vstupem pro tableau metodu bude množina formulí
predikátové logiky.
Cílem metody bude, tak jako v případě rezoluční metody,
najít spor v této množině.</dd></div>


<div class="definition" id="negation-normal-form"><dt>Negation normal form</dt><dd>Formule v negativní normální formě (NNF) je taková logická formule, která obsahuje negaci pouze v literálech.</dd></div>


</div><div class="section"><h3 id="tableau-pravidla-pro-predik-tovou-logiku">Tableau pravidla pro predikátovou logiku</h3>
<ul>
<li>Na začátku přepokládejme tableau tvořené jen jedním
uzlem - kořenem obsahujícím konjunkci všech formulí ze
vstupní množiny.</li>
<li>Někdy se také tento kořen označuje symbolem Т (top).
Tento uzel se obvykle v grafické podobě tabla nezobrazuje.</li>
<li>Nyní se začnou na tableau aplikovat postupně jednotlivá
pravidla.</li>
</ul>
<div class="definition" id="konjuknce"><dt>konjuknce</dt><dd>A &amp; B -&gt; připojíme větev s A a B</dd></div>


<div class="definition" id="disjunkce"><dt>disjunkce</dt><dd>A | B -&gt; vytvoříme jednu větev s A a druhou s B</dd></div>


<div class="definition" id="negace"><dt>negace</dt><dd>převedení negace blíže k literálům. Pokud budeme zpracovávat pomocí tableau metody pouze formule v tzv. negativní normální formě (NNF), není třeba žádné pravidlo pro zpracování negace zavádět.</dd></div>


<div class="definition" id="univerzalni-kvantifikace"><dt>univerzální kvantifikace</dt><dd>nahrazením všech volných výskytů proměnné x za novou proměnnou x’, která se ještě nikde v tableau nevyskytuje.</dd></div>


<div class="definition" id="existencni-kvantifikace"><dt>existenční kvantifikace</dt><dd>nahrazením všech volných výskytů x termem f(x1 ,…,xn). Zde f je nový funkční symbol, který se ještě nikde v tableau nevyskytuje.</dd></div>


<div class="definition" id="uzavreni-vetve"><dt>uzavření větve</dt><dd>pokud se na některé větvi v tableau vyskytují dva komplementární literály co dávají po unifikační substituci spor, potom aplikujeme substituci θ na všechny uzly tableau a takovou větev označíme za uzavřenou.</dd></div>


<div class="definition" id="uzavrene-tableau"><dt>uzavřené tableau</dt><dd>Tableau je uzavřené, pokud jsou všechny jeho větve uzavřené.</dd></div>


<div class="definition" id="leantap"><dt>LeanTAP</dt><dd>LeanTAP je jeden z nejkratších úplných dokazovačů pro predikátovou logiku. LeanTAP používá tableau metodu a skládá se z pěti klauzulí v programovacím jazyku Prolog. Jako vstup přepokládá dokazovač konjunkci skolemizovaných uzavřených formulí v NNF.</dd></div>


</div><div class="section"><h2 id="dpll-a-metody-pro-sat">DPLL a metody pro SAT</h2>
<div class="definition" id="sat"><dt>SAT</dt><dd>Boolean SATisfiability problem. Řeší problém nalezení ohodnocení proměnných v booleovské formuli bez kvantifikátorů tak, že je formule splněna.</dd></div>


<div class="definition" id="dpll"><dt>DPLL</dt><dd>Davis-Putnam-Logemann-Loveland algoritmus pro řešení SAT. The basic backtracking algorithm runs by choosing a literal, assigning a truth value to it, simplifying the formula and then recursively checking if the simplified formula is satisfiable. The DPLL algorithm enhances over the backtracking algorithm by the eager use of the following rules at each step: unit propagation and pure literal elimination.</dd></div>


<div class="definition" id="unit-clause"><dt>unit clause (jednotková klauzule)</dt><dd>je klausule která obsahuje právě jeden literál. Tento literál obsahuje nenastavenou proměnnou.</dd></div>


<div class="definition" id="unit-propagation"><dt>unit propagation (unit propagation)</dt><dd>If a clause is a unit clause, i.e. it contains only a single unassigned literal, this clause can only be satisfied by assigning the necessary value to make this literal true. Thus, no choice is necessary. In practice, this often leads to deterministic cascades of units, thus avoiding a large part of the naive search space.</dd></div>


<div class="definition" id="pure-vyskyt"><dt>pure výskyt</dt><dd>znamená, že se literál všude ve Φ vyskytuje buď ve tvaru x anebo se všude ve Φ vyskytuje ve tvaru ¬x.</dd></div>




<div class="definition" id="pure-literal-elimination"><dt>pure literal elimination</dt><dd>If a propositional variable occurs with only one polarity in the formula, it is called pure. Pure literals can always be assigned in a way that makes all clauses containing them true. Thus, these clauses do not constrain the search anymore and can be deleted.</dd></div>


<div class="definition" id="minisat"><dt>MiniSat</dt><dd>velmi výkonný SAT solver</dd></div>


<div class="definition" id="minisat-analyza-konfliktu"><dt>MiniSat – analýza konfliktu</dt><dd>Konflikt nastane pokud se nějaká klauzule stane nesplnitelnou během propagace unit klauzule (boolean_constraint_propagation()).</dd></div>


</div></body>
</html>
